<p>This exercise is a variant on the previous exercises.</p>
<p>We are now given an additional input -- a <code>Behavior t Int</code> -- which represents the upper limit that the counter is allowed to reach.</p>
<p>We are passing in a <code>Behavior t Int</code> as the limit instead of an <code>Int</code> to make the function as general as we can. If want the limit to be <code>5</code> we can pass in <code>pure 5</code>. If we want some other part of our program to decide on the limit or want to do something fancier, we can do that as well.</p>
<p>This is a common technique in FRP programs. Passing around arbitrary pieces of time-varying state as values is handy, so we do it often.</p>
<p>You should fill out this function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">limitExercise ::</span> <span class="dt">Reflex</span> t
              <span class="ot">=&gt;</span> <span class="dt">Behavior</span> t <span class="dt">Int</span>
              <span class="ot">-&gt;</span> <span class="dt">Behavior</span> t <span class="dt">Int</span>
              <span class="ot">-&gt;</span> <span class="dt">Event</span> t ()
              <span class="ot">-&gt;</span> <span class="dt">Event</span> t ()
              <span class="ot">-&gt;</span> <span class="dt">Event</span> t <span class="dt">Int</span>
limitExercise bCount bLimit eAdd eReset <span class="fu">=</span>
  never</code></pre></div>
<p>to make this happen.</p>
<p>Feel free to import and use solutions to previous exercises if you think that will help.</p>